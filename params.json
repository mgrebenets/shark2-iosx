{"name":"Shark2-iosx","tagline":"Build Shark 2.3.4 framework for iOS and OSX","body":"## What is Shark?\r\nSHARK provides libraries for the design of adaptive systems, including methods for linear and nonlinear optimization (e.g., evolutionary and gradient-based algorithms), kernel-based algorithms and neural networks, and other machine learning techniques.\r\n\r\nThis script is created to build framework for Shark version 2.3.4.\r\n\r\nFor a newer alpha release of Shark 3.0 please visit [http://image.diku.dk/shark](http://image.diku.dk/shark).\r\n\r\nUnlike the GitHub project [README](https://github.com/mgrebenets/shark2-iosx) this post goes into details of the build process.\r\n\r\n## Steps\r\nThe process of building framework consists of the following steps\r\n\r\n- Get Source Code\r\n- Patch Source Code\r\n- Configure and Build\r\n- Lipo Library\r\n- Package Framework\r\n\r\n### Get Source Code\r\nThis step is as simple as just downloading the zip archive.\r\n\r\n``` bash\r\n# download\r\ncurl -L --progress-bar -o shark-2.3.4.zip \"http://sourceforge.net/projects/shark-project/files/Shark%20Core/Shark%202.3.4/shark-2.3.4.zip/download\"\r\n\r\n# unzip\r\nunzip -q shark-2.3.4.zip -d src\r\n```\r\n\r\n### Patch Source Code\r\nThat's where some fun begins. The original source code was developed with gcc 4.2, while we're trying to compile it with clang 5.0. There's been years of development since then, both in terms of compilers and C++ standards. No wonder clang fails with quite a few errors.\r\n\r\n#### Default Constructor\r\nLet's start with the patch that I believe might have some impact on the way you should use the library. In file `ReClam/EarlyStopping.cpp`, line 78.\r\n\r\n``` c++\r\nEarlyStopping::EarlyStopping(unsigned sl = 5)\r\n```\r\n\r\nNote the use of default value for the only parameter of the constructor. There's an in-depth discussion of this issue on [StackOverflow](http://stackoverflow.com/questions/18313509/default-argument-gcc-vs-clang)\r\n\r\nThe fix is to remove default value for `sl` parameter. Since `EarlyStopping` constructor is not referenced anywhere in the library source code it is up to you, as a library user, to provide some value to it and not to rely on any default values.\r\n\r\n#### No 'finite' for iOS\r\nNext issue is with `finite` method. This method is not included for iOS target architectures. You will get this error when building both for iOS Device and Simulator. Here's [some referencee](http://createdigitalnoise.com/discussion/1754/can-t-compile-expr-with-xcode-4-5-2-same-project-works-in-xcode-4-4-1) to this problem.\r\n\r\nThe suggested fix is to replace calls to `finite` with `isfinite`. The best way to do it is to use `#define` macro and place it in the `SharkDefs.h` file.\r\n\r\n``` c++\r\n#if defined(__APPLE__) && defined(__MACH__)\r\n/* Apple OSX and iOS (Darwin). */\r\n#include <TargetConditionals.h>\r\n#if TARGET_IPHONE_SIMULATOR == 1\r\n/* iOS in Xcode simulator */\r\n#define finite(x) isfinite(x)\r\n#elif TARGET_OS_IPHONE == 1\r\n/* iOS on iPhone, iPad, etc. */\r\n#define finite(x) isfinite(x)\r\n// #define drem(x, y) remainder(x, y)\r\n#elif TARGET_OS_MAC == 1\r\n/* OSX */\r\n#endif\r\n#endif\r\n```\r\n\r\n* First, check if `__APPLE__` and `__MACH___` are defined to detect Apple's OS.\r\n* Then include `<TargetConditionals.>` to enable `TARGET_IPHONE_SIMULATOR`, `TARGET_OS_IPHONE` and `TARGET_OS_MAC` defines.\r\n* Finally, use those three defines to redefine `finite(x)` as `isfinite(x)` for iOS Device and Simulator targets.\r\n\r\nNote the commented line for `drem(x, y)`. This method is not available for iOS targets as well and should be replaced with `remainder(x, y)`. Shark library doesn't use it, but you'll know what to do if you ever have a problem with `drem`.\r\n\r\n#### FileUtil Fixes\r\nNext comes `FileUtil.h`. There's a couple of things that clang doesn't like.\r\n\r\nFirst is the use of `FileUtil` namespace. Clang can't resolve references to `iotype` type, as well as references to three constants `SetDefault`, `ScanFrom` and `PrintTo`.\r\n\r\nThe fix is to use namespace scope.\r\n``` c++\r\niotype --> FileUtil::iotype\r\nSetDefault --> FileUtil::SetDefault\r\nScanFrom --> FileUtil::ScanFrom\r\nPrintTo --> FileUtil::PrintTo\r\n```\r\n\r\nFinally, `io_strict` is calling `scanFrom_strict` and `printTo_strict`, which are defined further down in the header file.\r\n\r\nThe fix for this problem is simple - move declaration of `io_strict` to the bottom of the header file.\r\n\r\n#### double erf(double) throw();\r\nCompilation of `Mixture/MixtureOfGaussians.cpp` fails with error caused by the following line\r\n\r\n``` c++\r\nextern \"C\" double erf(double) throw();\r\n```\r\n\r\nClang complains that `extern \"C\"` declaration doesn't match the actual prototype of `erf`. Removing `throw()` statement solves this issue.\r\n\r\n#### RandomVector this->p\r\nLine 72 in `Mixture/RandomVector.h` references `p` \"as is\".\r\n\r\n``` c++\r\nfor (unsigned k = x.dim(0); k--;) {\r\n    l += log(Shark::max(p(x[ k ]), 1e-100));    // !!!\r\n}\r\n```\r\n\r\n`p` is a public member function of `RandomVar` and `RandomVector` subclasses `RandomVar`.\r\n\r\n``` c++\r\n// RandomVar.h\r\ntemplate < class T >\r\nclass RandomVar\r\n{\r\npublic:\r\n    // ***\r\n    virtual double p(const T&) const = 0;\r\n    // ***\r\n}\r\n\r\n// RandomVector.h\r\ntemplate < class T >\r\nclass RandomVector : public RandomVar< Array< T > >\r\n{\r\npublic:\r\n    // ***\r\n}\r\n```\r\n\r\nThus the fix is as simple as replacing reference to `p` with `this->p`. Note the triple exclamation mark comment in the original code (`// !!!`), looks like developers knew something could go wrong with this code.\r\n\r\n#### Make It Static\r\nThe last patch is actually not a fix. Since we want to build a static library, we need to modify original `CMakeList.txt`, otherwise the dynamic library is built.\r\n\r\n``` cmake\r\nADD_LIBRARY( shark STATIC ${SRCS} )\r\n```\r\n\r\nIf you want to build a dynamic (shared) library, you'll need to use the original line.\r\n\r\n``` cmake\r\nADD_LIBRARY( shark SHARED ${SRCS} )\r\n```\r\n\r\n#### Apply Patch\r\nAll the changes described above are available as a patch file [shark.patch](https://github.com/mgrebenets/shark2-iosx/blob/master/shark.patch).\r\nTo create patch file use `diff` utility.\r\n\r\n``` bash\r\ndiff -crB shark_orig shark_patched > shark.patch\r\n```\r\n\r\nTo apply the patch use `patch` command.\r\n``` bash\r\npatch -d src/Shark -p1 --forward -r - -i ../../shark.patch\r\n```\r\n\r\n* The `--forward` flag will disable interactive mode and all the prompts\r\n* `-d` flag is used to specify the source code folder, the utility will `cd` into specified folder\r\n* `-r -` option specifies that no `.rej` files should be created if the patch is already applied (or in case of any other error)\r\n* note the relative path for `-i ../../shark.patch`, this is needed because `-d` flag is used and patch command will be executed in `src/Shark` folder\r\n\r\n### Configure and Build\r\n\r\nNow when all the compile errors are fixed it's time to build static library for all target platforms.\r\n\r\nBefore we run `make` we have to configure the build (that also creates `Makefile`) and for this purpose we're going to stick with `cmake`.\r\n\r\nWe'll have to run `cmake` and then `make` 3 times to build 3 static libraries for following targets\r\n- iOS Devices (armv7, armv7s, x86_64)\r\n- iOS Simulator (i386, x86_64)\r\n- Mac OS X (x86_64)\r\n\r\nThe libraries for iOS Device and Simulator will later be merged into one fat library which you can use for your iOS development and release.\r\n\r\n#### cmake Basics\r\nEach of the build targets needs to be configured differently with `cmake`.\r\nThe following options have to be configured:\r\n\r\n- C++ Compiler (`CMAKE_CXX_COMPILER`)\r\n\r\nBy default the `/usr/bin/c++` is used as C++ compiler, but we want to build using `clang++` compiler from Xcode toolchain.\r\n\r\n- C++ Compiler Flags (`CMAKE_CXX_FLAGS`)\r\n\r\nThe C++ compiler flags are used to specify target architectures and other important build settings.\r\n\r\n- C Compiler (`CMAKE_C_COMPILER`)\r\n\r\nEven though there's no plain C code, the C compiler needs to be configured, since the whole project by default is C/C++ project.\r\n\r\n- System Root (`CMAKE_OSX_SYSROOT`)\r\n\r\nThis is where build system will look for all the standard library includes.\r\n\r\n- Install Prefix (`CMAKE_INSTALL_PREFIX`)\r\n\r\nThis is optional, the prefix is used to tell `make install` where to install your library. Normally it's used when you build a shared library and then want to place it somewhere in your `/usr/local/lib`.\r\n\r\n- Build System Generator (`-G` flag)\r\nWe plan to use `make` utility with `Makefile`, so this option will be `\"Unix Makefiles\"`.\r\n\r\n#### Xcode Toolchain\r\nLet's start with asking Xcode where all the tools are.\r\n\r\n``` bash\r\nXCODE_ROOT=$(xcode-select -print-path)\r\nXCODE_ARM_ROOT=$XCODE_ROOT/Platforms/iPhoneOS.platform/Developer\r\nXCODE_SIM_ROOT=$XCODE_ROOT/Platforms/iPhoneSimulator.platform/Developer\r\nXCODE_TOOLCHAIN_BIN=$XCODE_ROOT/Toolchains/XcodeDefault.xctoolchain/usr/bin\r\nCXX_COMPILER=${XCODE_TOOLCHAIN_BIN}/clang++\r\nC_COMPILER=${XCODE_TOOLCHAIN_BIN}/clang\r\n```\r\n\r\nNow we have all we need: C and C++ compiler, system roots for iOS Device and Simulator. For OS X the `cmake` is smart enough to find system root automatically.\r\n\r\nIt's time to configure build for each target.\r\n\r\n##### iOS Device\r\nWe don't want to mess up with the original source code, so let's build in a separate folder.\r\n``` bash\r\nmkdir -p build/ios\r\ncd build/ios\r\n```\r\n\r\nTo configure the build, we already have `CXX_COMPILER`, `C_COMPILER`. We still need to configure is C++ Compiler Flags and System Root.\r\n\r\nOur goal is to support 3 iOS Device architectures: `armv7`, `armv7s` and `arm64`, that's where `-arch` option is used.\r\n\r\nThe System Root is the root folder of iPhone OS 7.0 SDK, it's located in the `XCODE_ARM_ROOT`, which we defined above.\r\n\r\n``` bash\r\nCXX_FLAGS=\"-arch armv7 -arch armv7s -arch arm64\"\r\nSYSTEM_ROOT=${XCODE_ARM_ROOT}/SDKs/iPhoneOS7.0.sdk\r\n```\r\n\r\nNow we can run `cmake`.\r\n``` bash\r\ncmake \\\r\n  -DCMAKE_CXX_COMPILER=$CXX_COMPILER \\\r\n  -DCMAKE_OSX_SYSROOT=\"$SYSTEM_ROOT\" \\\r\n  -DCMAKE_C_COMPILER=$C_COMPILER \\\r\n  -DCMAKE_CXX_FLAGS=\"$CXX_FLAGS\" \\\r\n  -G \"Unix Makefiles\" \\\r\n  ../../src/Shark\r\n```\r\n\r\n> If you are trying to run this command right now, you'll face the \"C Compiler Test\" error. For a work-around check the \"cmake Tricks\" section below.\r\n\r\n##### iOS Simulator\r\nFor iOS Simulator we're going to use `i386` and `x86_64` architectures, the latter one will allow you to test on \"iPad Retina (64-bit)\" and other 64-bit device simulators.\r\n\r\nThe System Root is `${XCODE_SIM_ROOT}/SDKs/iPhoneSimulator7.0.sdk`.\r\n\r\nAnd then there's one more very important C++ compiler flag: `-mios-simulator-version-min=7.0`. If you don't set this flag, the build target will be OS X.\r\n\r\n``` bash\r\nCXX_FLAGS=\"-arch i386 -arch x86_64 -mios-simulator-version-min=7.0\"\r\nSYSTEM_ROOT=${XCODE_SIM_ROOT}/SDKs/iPhoneSimulator7.0.sdk\r\n\r\ncmake \\\r\n  -DCMAKE_CXX_COMPILER=$CXX_COMPILER \\\r\n  -DCMAKE_OSX_SYSROOT=\"$SYSTEM_ROOT\" \\\r\n  -DCMAKE_C_COMPILER=$C_COMPILER \\\r\n  -DCMAKE_CXX_FLAGS=\"$CXX_FLAGS\" \\\r\n  -G \"Unix Makefiles\" \\\r\n  ../../src/Shark\r\n```\r\n\r\n##### Mac OS X\r\nFor OS X we only need to configure C and C++ compilers, then leave the rest of settings to `cmake`.\r\n\r\n``` bash\r\ncmake \\\r\n  -DCMAKE_CXX_COMPILER=$CXX_COMPILER \\\r\n  -DCMAKE_C_COMPILER=$C_COMPILER \\\r\n  -G \"Unix Makefiles\" \\\r\n  ../../src/Shark\r\n```\r\n\r\n#### cmake Tricks\r\n\r\n##### Compiler Test\r\nNow, if you tried to run any of the above commands you definitely face the \"C Compiler Test\" error. `cmake` checks `clang` compiler by trying to compile some test code and that check fails. I tried to use different approaches to pass the compiler test, such as setting project type to `NONE` in `CMakeLists.txt`, but nothing worked for me. So I had to come up with somewhat dirty trick to fix this problem:\r\n\r\n- Run `cmake` once with no properties set and no generator option, aka \"Initial Run\"\r\n\r\nThis will pick up default C and C++ compilers, pass the compiler test, create `CMakeCache.txt` and `CMakeFiles` folder. If you `cmake` again, the compiler test won't be performed any more.\r\n\r\n##### Changed Parameters\r\nIf you just ran `cmake` for the 2nd time with all the properties set (compilers, system root, flags, etc.) you might think that you're good to go and can just `make` stuff.\r\n\r\nBut wait... Run `ccmake ../../src/Shark` and have a look at all the build settings. You'll notice that C++ Compiler Flags are not set. This is specifics of `cmake`. If you change some important build settings, like compiler flags, the `cmake` will detect the change and spit out a message like \"C++ Compiler Flags changed, you need to configure build to apply the changes.\" Well, you won't see this message with `cmake`, but you can play around with `ccmake` and see it.\r\n\r\nIn short, you need to run `cmake` twice if you change some specific settings. That's why you'll see `cmakeRun` called twice in `build.sh` for iOS target. And yes, with the initial run to pass compiler test check, you'll end up calling `cmake` for up to 3 times.\r\n\r\n#### Make It!\r\nAt last you're ready to make it!\r\n\r\nAt this point it is as simple as\r\n``` bash\r\nmake -j16\r\n```\r\n\r\nThe `-j16` will parallelize the build and make it way faster than plain `make`.\r\n\r\nIt doesn't take long and in the end you'll have `libshark.a` static library. Check it with `file` utility to make sure you have all the architectures in place.\r\n\r\n``` bash\r\n$ file build/ios/libshark.a\r\nbuild/ios/libshark.a: Mach-O universal binary with 3 architectures\r\nbuild/ios/libshark.a (for architecture armv7):  current ar archive random library\r\nbuild/ios/libshark.a (for architecture armv7s): current ar archive random library\r\nbuild/ios/libshark.a (for architecture cputype (16777228) cpusubtype (0)):  current ar archive random library\r\n\r\n$ file build/sim/libshark.a\r\nbuild/sim/libshark.a: Mach-O universal binary with 2 architectures\r\nbuild/sim/libshark.a (for architecture i386): current ar archive random library\r\nbuild/sim/libshark.a (for architecture x86_64): current ar archive random library\r\n\r\n$ file build/osx/libshark.a\r\nbuild/osx/libshark.a: current ar archive random library\r\n```\r\n\r\n### Lipo Library\r\nSo you have a static library for iOS Devices and another one for iOS Simulator. To have the convenience of using same framework for device and simulator you need to merge these two static libraries into one.\r\n\r\nThe `lipo` utility is what you need.\r\n``` bash\r\nmkdir -p lib/ios\r\n$XCODE_TOOLCHAIN_BIN/lipo -create build/ios/libshark.a build/sim/libshark.a -o lib/ios/libshark.a\r\n```\r\n\r\nNow run `file lib/ios/libshark.a` and make sure the fat library includes 5 architectures.\r\n\r\nIf you're targeting OS X, just copy `build/osx/libshark.a` to `lib/osx`. It only includes one x86_64 architecture.\r\n\r\n### Package Framework\r\nIt is time to nicely wrap the static library in a neat framework package.\r\n\r\nThere's plenty of guides how to do that using bash script. The general steps are described below.\r\n\r\n##### Create Framework Bundle\r\nCreate the framework folder structure (bundle) with proper symbolic links. Name the framework folder as `Shark.framework`\r\n\r\n``` bash\r\nShark.framework/\r\n├── Documentation -> Versions/Current/Documentation\r\n├── Headers -> Versions/Current/Headers\r\n├── Resources -> Versions/Current/Resources\r\n└── Versions\r\n    ├── A\r\n    │   ├── Documentation\r\n    │   ├── Headers\r\n    │   └── Resources\r\n    └── Current -> A\r\n```\r\n\r\n##### Copy Static Library\r\nRename static library to `Shark` and copy it into framework bundle\r\n\r\n``` bash\r\ncp build/ios/libshark.a Shark.framework/Versions/A/Shark\r\n```\r\n\r\n##### Copy Headers\r\nCopy all the headers to framework bundle `Headers` folder.\r\n\r\nStart with copying all the headers from `src/include` to framework bundle.\r\nThen remove unused `statistics.h` header. If you check `CMakeLists.txt` in the source folder, you'll notice that there's no `INSTALL` rule for `statistics.h` header.\r\n\r\n``` bash\r\ncp -r src/Shark/include/* Shark.framework/Headers/\r\nrm Shark.framework/Headers/statistics.h\r\n```\r\n\r\n\r\n###### Patch Headers\r\nYou might think \"What's next step?\" at this point, but there's some serious patching to be applied to header files.\r\n\r\nIf you just copy the headers \"as is\", you'll run into a number of nasty compile errors when including headers from the framework. While using a shared library and running on OS X I could apply some workaround for this issue using Header Search Path and other build settings, but that's not so easy when all the headers come from a framework bundle.\r\n\r\nWhile trying to solve the problem I looked into another well known and well built library - `boost`. All (well, all that I've seen) the includes in the `boost` library follow the same convention: in the `#include` directive the header path starts with `boost/`, for example\r\n\r\n``` c++\r\n#include \"boost/config.hpp\"\r\n#include <boost/type_traits/remove_reference.hpp>\r\n```\r\n\r\nSo I used `sed` to patch all the headers in the framework bundle. The patching does the following:\r\n- Find all includes of `SharkDefs.h` and replace with `Shark/SharkDefs.h`\r\n- Find all includes of library components and add `Shark/` to the include path.\r\n\r\nBy components, I mean all the sub-folders in `Headers` folder:\r\n`Array`, `Rng`, `LinAlg`, `FileUtil`, `EALib`, `MOO-EALib`, `ReClaM`, `Mixture`, `TimeSeries`, `Fuzzy`.\r\n\r\nAnd then there was a number of bad-formed include statements like `#include<SharkDefs.h>` with no space after `#include`.\r\n\r\nThe bash script that does the job using `sed` with modern regular expression syntax and in-place edits.\r\n\r\n``` bash\r\n# avoid invalid character sequence errors\r\nexport LC_TYPE=C\r\nexport LANG=C\r\n\r\n# fix missing spaces in include directives\r\n# fix include path for SharkDefs.h\r\n# fix include paths for all components\r\n# use -E for modern regex syntax and avoid those gnu vs non-gnu sed issues\r\ncomponents=\"Array|Rng|LinAlg|FileUtil|EALib|MOO-EALib|ReClaM|Mixture|TimeSeries|Fuzzy\"\r\nfind Shark.framework/Headers -type f -exec \\\r\n    sed -E -i '' \\\r\n    -e \"s,#include([<\\\"]),#include \\1,g\" \\\r\n    -e \"s,#include([ \\t])([<\\\"])(SharkDefs.h),#include\\1\\2Shark/\\3,g\" \\\r\n    -e \"s,#include([ \\t])([<\\\"])(${components}/),#include\\1\\2Shark/\\3,g\" \\\r\n    {} +\r\n```\r\n\r\n##### Create Info.plist\r\nThe last step is to create `Info.plist` in `Shark.framework/Resources`\r\n\r\n``` bash\r\nFRAMEWORK_NAME=Shark\r\nFRAMEWORK_CURRENT_VERSION=2.3.4\r\n\r\ncat > Shark.framework/Resources/Info.plist <<EOF\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\r\n<plist version=\"1.0\">\r\n<dict>\r\n    <key>CFBundleDevelopmentRegion</key>\r\n    <string>English</string>\r\n    <key>CFBundleExecutable</key>\r\n    <string>${FRAMEWORK_NAME}</string>\r\n    <key>CFBundleIdentifier</key>\r\n    <string>dk.diku.image</string>\r\n    <key>CFBundleInfoDictionaryVersion</key>\r\n    <string>6.0</string>\r\n    <key>CFBundlePackageType</key>\r\n    <string>FMWK</string>\r\n    <key>CFBundleSignature</key>\r\n    <string>????</string>\r\n    <key>CFBundleVersion</key>\r\n    <string>${FRAMEWORK_CURRENT_VERSION}</string>\r\n</dict>\r\n</plist>\r\nEOF\r\n```\r\n\r\n## Conclusion\r\nThat's it!\r\n\r\nDrag & drop the framework into your Xcode project and start coding.\r\n\r\nBut I'd recommend to use [CocoaPods](http://cocoapods.org), the framework is available under the name `Shark-SDK`.\r\n\r\n``` ruby\r\n# Podfile\r\npod 'Shark-SDK'\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}